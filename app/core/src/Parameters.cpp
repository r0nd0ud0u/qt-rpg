// DO NOT EDIT HERE. Generated by parameters tool box v0.5 - 03:30PM on September 06, 2022
// Offline parameters reader class (C++) for application skycbt-mission-window 0.0.1
#include "Parameters.hpp"

#include <algorithm>
#include <sstream>

#include "Encryption.h"

using std::string;
using std::tuple;
using std::vector;
using std::to_string;

template<typename T> static inline bool vec_contains(vector<T> vec, T val)
{
    return std::find(vec.begin(), vec.end(), val) != vec.end();
}

const vector<string> Parameters::m_glistPossibleSections =
{
    "GLOBAL",
};

Parameters Parameters::ReadConfigFile(const AbstractIniFile& iniFile)
{
    Parameters params;

    for (const auto& itSection : iniFile.GetIniProfileSectionNames()) {
        vector<key> listSectionKeys = iniFile.GetIniProfileSection(itSection);
        params.m_listAllSectionsReadInFile.push_back(tuple<sec, vector<key>>(itSection, listSectionKeys));
    }

    ////////////////////
    // Section GLOBAL //
    ////////////////////
    {
        sec sectionName = "GLOBAL";
        params.RegisterFoundExpectedSection(sectionName);
        params.GLOBAL.m_strSectionNameAbstract = sectionName;
        params.GLOBAL.m_strSectionNameReal = sectionName;
        params.GLOBAL.DecodeStr(iniFile, "LOG_PATH", params.GLOBAL.m_LOG_PATH, params);
        params.GLOBAL.DecodeStr(iniFile, "SKYOPSGATEWAY_TCPSERVER_ADDRESS", params.GLOBAL.m_SKYOPSGATEWAY_TCPSERVER_ADDRESS, params);
        params.GLOBAL.DecodeStr(iniFile, "SKYOPSGATEWAY_TCPSERVER_PORT", params.GLOBAL.m_SKYOPSGATEWAY_TCPSERVER_PORT, params);
        {
        	bool value = params.GLOBAL.m_IS_WINDOW_SHOWN;
        	params.GLOBAL.DecodeBool(iniFile, "IS_WINDOW_SHOWN", value, params);
        	params.GLOBAL.m_IS_WINDOW_SHOWN = value;
        }
        {
        	bool value = params.GLOBAL.m_DEBUG_MODE;
        	params.GLOBAL.DecodeBool(iniFile, "DEBUG_MODE", value, params);
        	params.GLOBAL.m_DEBUG_MODE = value;
        }
    }
    
    return params;
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////

void ParametersSection::RegisterParamRead(const string& strParamNameReal, const string& strValue, bool bIsValid, Parameters& oparam)
{
    if (! bIsValid)
    {
        m_listIncorrectValues.push_back(tuple<string, string>(strParamNameReal, strValue));
        oparam.RegisterIncorrectValue(m_strSectionNameReal, strParamNameReal, strValue);
    }
    oparam.m_listReadExpectedParameters.push_back(tuple<string, string>(m_strSectionNameReal, strParamNameReal));
}

bool ParametersSection::DecodeStr(const AbstractIniFile& iniFile, const string& strParamNameReal, string& outVal, Parameters& oparam)
{
    bool keyExist = true;
    const string strValue = iniFile.GetIniProfileString(m_strSectionNameReal, strParamNameReal, &keyExist);
    if (! keyExist)
        return false;

    outVal = strValue;
    RegisterParamRead(strParamNameReal, strValue, true, oparam);
    return true;
}

bool ParametersSection::DecodePwd(const AbstractIniFile& iniFile, const string& strParamNameReal, string& outVal, Parameters& oparam)
{
    bool keyExist = true;
    const string strValue = iniFile.GetIniProfileString(m_strSectionNameReal, strParamNameReal, &keyExist);
    if (! keyExist)
        return false;

    if (!strValue.empty())
        outVal = Encryption::decipher(strValue);
    RegisterParamRead(strParamNameReal, strValue, true, oparam);
    return true;
}

bool ParametersSection::DecodeBool(const AbstractIniFile& iniFile, const string& strParamNameReal, bool& outVal, Parameters& oparam)
{
    bool keyExist = true;
    const string strValue = iniFile.GetIniProfileString(m_strSectionNameReal, strParamNameReal, &keyExist);
    if (! keyExist)
        return false;

    bool isValid   = false;
    bool isPresent = true;
    outVal         = false;

    if (IniTools::CompareEqualsNoCase(strValue, "YES"))
    {
        outVal = true;
        isValid = true;
    }
    else if (IniTools::CompareEqualsNoCase(strValue, "TRUE"))
        outVal  = true; // Not valid
    else if (IniTools::CompareEqualsNoCase(strValue, "NO"))
        isValid = true; // Keep false and valid
    else if (IniTools::CompareEqualsNoCase(strValue, "FALSE"))
    {
        //nothing (outVal = false  and  isValid = false) but we want isPresent = true
    }
    else
        isPresent = false; // Keep false + not valid + not present

    RegisterParamRead(strParamNameReal, strValue, isValid, oparam);
    return isPresent;
}

bool ParametersSection::DecodeTriStateBool(const AbstractIniFile& iniFile, const std::string& strParamNameReal, tTriStateBool& outVal, Parameters& oparam)
{
    bool keyExist = true;
    const string strValue = iniFile.GetIniProfileString(m_strSectionNameReal, strParamNameReal, &keyExist);
    if (! keyExist)
        return false;

    bool isValid = false;
    bool isPresent = true;
    outVal       = tTriStateBool_Default;

    if (IniTools::CompareEqualsNoCase(strValue, "YES"))
    {
        outVal = tTriStateBool_True;
        isValid = true;
    }
    else if (IniTools::CompareEqualsNoCase(strValue, "TRUE"))
    {
        outVal  = tTriStateBool_True;
        isValid = false; // Not valid
    }
    else if (IniTools::CompareEqualsNoCase(strValue, "NO"))
    {
        outVal = tTriStateBool_False;
        isValid = true;
    }
    else if (IniTools::CompareEqualsNoCase(strValue, "FALSE"))
    {
        outVal = tTriStateBool_False;
        isValid = true; // Not valid
    }
    else if (IniTools::CompareEqualsNoCase(strValue, "DEFAULT"))
    {
        outVal = tTriStateBool_Default;
        isValid = true;
    }
    else
        isPresent = false; // Keep default + not valid + not present

    RegisterParamRead(strParamNameReal, strValue, isValid, oparam);
    return isPresent;
}

bool ParametersSection::DecodeInt(const AbstractIniFile& iniFile, const string& strParamNameReal, int& outVal, int base, Parameters& oparam)
{
    bool keyExist = true;
    const string strValue = iniFile.GetIniProfileString(m_strSectionNameReal, strParamNameReal, &keyExist);
    if (! keyExist)
        return false;

    bool isValid  = true;
    try
    {
        if (base == 16 && (strValue.size() < 3 || strValue.compare(0, 2, "0x") != 0))
            base = 10;
        outVal = std::stoi(strValue, nullptr, base);
    }
    catch (std::invalid_argument&)
    {
        isValid = false;
    }
    catch (std::out_of_range&)
    {
        isValid = false;
    }
    RegisterParamRead(strParamNameReal, strValue, isValid, oparam);
    return isValid;
}

bool ParametersSection::DecodeLong(const AbstractIniFile& iniFile, const string& strParamNameReal, int64_t& outVal, int base, Parameters& oparam)
{
    bool keyExist = true;
    const string strValue = iniFile.GetIniProfileString(m_strSectionNameReal, strParamNameReal, &keyExist);
    if (! keyExist)
        return false;

    bool isValid  = true;
    try
    {
        outVal = std::stoll(strValue, nullptr, base);
    }
    catch (std::invalid_argument&)
    {
        isValid = false;
    }
    catch (std::out_of_range&)
    {
        isValid = false;
    }
    RegisterParamRead(strParamNameReal, strValue, isValid, oparam);
    return isValid;
}

bool ParametersSection::DecodeDouble(const AbstractIniFile& iniFile, const string& strParamNameReal, double& outVal, Parameters& oparam)
{
    bool keyExist = true;
    const string strValue = iniFile.GetIniProfileString(m_strSectionNameReal, strParamNameReal, &keyExist);
    if (! keyExist)
        return false;

    bool isValid  = true;
    try
    {
        outVal = std::stod(strValue);
    }
    catch (std::invalid_argument&)
    {
        isValid = false;
    }
    catch (std::out_of_range&)
    {
        isValid = false;
    }
    RegisterParamRead(strParamNameReal, strValue, isValid, oparam);
    return isValid;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////

vector<Parameters::sec> Parameters::GetListUnexpectedSections() const
{
    vector<sec> listUnexpectedSections;
    for (auto& itSectionInFile : m_listAllSectionsReadInFile)
    {
        sec strSectionName = std::get<0>(itSectionInFile);
        if (! vec_contains(m_listFoundExpectedSections, strSectionName))
            listUnexpectedSections.push_back(strSectionName); // not found : incorrect section
    }
    return listUnexpectedSections;
}

vector<Parameters::secKey> Parameters::GetListUnexpectedKeys() const
{
    vector<secKey> listUnexpectedKeys;
    for (auto& itSectionInFile : m_listAllSectionsReadInFile)
    {
        sec strSectionName = std::get<0>(itSectionInFile);
        if (! vec_contains(m_listFoundExpectedSections, strSectionName))
            continue; // skip incorrect section : already handled in GetListUnexpectedSections()

        for (auto& strKey : std::get<1>(itSectionInFile))
        {
            bool bWasExpected = false;
            for (auto& itFoundExpectedParam : m_listReadExpectedParameters)
            {
                if (std::get<0>(itFoundExpectedParam) == strSectionName && std::get<1>(itFoundExpectedParam) == strKey)
                {
                    bWasExpected = true;
                    break;
                }
            }
            if (! bWasExpected)
                listUnexpectedKeys.push_back(secKey{strSectionName, strKey});
        }
    }
    return listUnexpectedKeys;
}

vector<Parameters::secKeyVal> Parameters::GetListIncorrectValues() const
{
    return m_listIncorrectValues;
}

vector<Parameters::secKeyLegacyBoth> Parameters::GetListLegacyParams() const
{
    return m_listLegacyParams;
}

void Parameters::RegisterIncorrectValue(const sec& strSection, const key& strKey, const val& strValue)
{
    m_listIncorrectValues.push_back(secKeyVal{strSection, strKey, strValue});
}

void Parameters::RegisterFoundExpectedSection(const sec& strSection)
{
    if (! vec_contains(m_listFoundExpectedSections, strSection))
        m_listFoundExpectedSections.push_back(strSection);
}
void Parameters::RegisterLegacyParam(const sec& strSection, const key& strKeyNew, const key& strKeyLegacy, const bool& bAreBothPresent)
{
    m_listLegacyParams.push_back(secKeyLegacyBoth { strSection, strKeyNew, strKeyLegacy, bAreBothPresent });
}
